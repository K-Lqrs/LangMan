//	inner class YAML : I {
//		override fun startLoad(
//			data: Map<String, Any>,
//			lang: String
//		) {
//			logger.logIfDebug("Starting to process YAML and map message keys for language: $lang")
//
//			val messageKeyMap: MutableMap<String, MessageKey<P, C>> = mutableMapOf()
//			val messageMap: MutableMap<MessageKey<P, C>, String> = mutableMapOf()
//
//			scanForMessageKeys(messageKeyMap)
//			logger.logIfDebug("MessageKey map generated with ${messageKeyMap.size} keys for language: $lang")
//
//			processYamlData("", data, messageKeyMap, messageMap)
//			logger.logIfDebug("YAML data processed for language: $lang with ${messageMap.size} entries")
//
//			messages[lang] = messageMap
//			logger.logIfDebug("Message map stored for language: $lang")
//		}
//
//		private fun scanForMessageKeys(
//			messageKeyMap: MutableMap<String, MessageKey<P, C>>
//		) {
//			logger.logIfDebug("Starting scan for message keys of expected type: ${expectedMKType.simpleName}")
//
//			val reflections = Reflections(
//				ConfigurationBuilder()
//					.setUrls(ClasspathHelper.forPackage(packName))
//					.setScanners(Scanners.SubTypes)
//			)
//
//			val messageKeyClasses = reflections.getSubTypesOf(MessageKey::class.java)
//			logger.logIfDebug("Found ${messageKeyClasses.size} potential MessageKey classes to examine")
//
//			messageKeyClasses.forEach { clazz ->
//				logger.logIfDebug("Examining class: ${clazz.kotlin.qualifiedName}")
//				mapMessageKeys(clazz.kotlin, "", messageKeyMap)
//			}
//
//			logger.logIfDebug("Completed scanning for message keys.")
//			logger.logIfDebug("Final MessageKey map contains: ${messageKeyMap.keys.joinToString(", ")}")
//		}
//
//		private fun mapMessageKeys(
//			clazz: KClass<out MessageKey<*, *>>,
//			currentPath: String = "",
//			messageKeyMap: MutableMap<String, MessageKey<P, C>>
//		) {
//			val castedExpectedMKType = expectedMKType as KClass<out MessageKey<P, C>>
//
//			val className = clazz.simpleName ?: return
//			val fullPath = if (currentPath.isEmpty()) className else "$currentPath.$className"
//
//			val normalizedKey = normalizeKey(fullPath)
//
//			logger.logIfDebug("Mapping key for class: $className, normalized: $normalizedKey")
//
//			val objectInstance = clazz.objectInstance ?: clazz.createInstanceOrNull()
//			if (objectInstance != null && castedExpectedMKType.isInstance(objectInstance)) {
//				if (!messageKeyMap.containsKey(normalizedKey)) {
//					messageKeyMap[normalizedKey] = objectInstance as MessageKey<P, C>
//					logger.logIfDebug("Registered key: $normalizedKey")
//				}
//			}
//
//			clazz.nestedClasses.forEach { nestedClass ->
//				if (nestedClass.isSubclassOf(castedExpectedMKType)) {
//					mapMessageKeys(nestedClass as KClass<out MessageKey<P, C>>, fullPath, messageKeyMap)
//				}
//			}
//		}
//
//		private fun processYamlData(
//			prefix: String,
//			data: Map<String, Any>,
//			messageKeyMap: Map<String, MessageKey<P, C>>,
//			messageMap: MutableMap<MessageKey<P, C>, String>
//		) {
//			logger.logIfDebug("Starting YAML data processing with prefix: '$prefix'")
//			logger.logIfDebug("Available keys in MessageKey map: ${messageKeyMap.keys.joinToString(", ")}")
//
//			for ((key, value) in data) {
//				val currentPrefix = if (prefix.isEmpty()) key else "$prefix.$key"
//				val normalizedPrefix = normalizeKey(currentPrefix)
//				logger.logIfDebug("Processing key: $key, currentPrefix: $currentPrefix, normalized: $normalizedPrefix")
//
//				if (key == "langVersion") {
//					logger.logIfDebug("Skipping langVersion key")
//					continue
//				}
//
//				when (value) {
//					is String -> {
//						val messageKey = messageKeyMap[normalizedPrefix]
//						if (messageKey != null) {
//							logger.logIfDebug("Mapping message: $normalizedPrefix -> $value")
//							messageMap[messageKey] = value
//						} else {
//							logger.logIfDebug("No message key found for YAML path: $normalizedPrefix", LogLevel.WARN)
//						}
//					}
//
//					is List<*> -> {
//						logger.logIfDebug("Processing list at path: $normalizedPrefix with ${value.size} items")
//						value.forEachIndexed { index, element ->
//							val listPrefix = "$currentPrefix.item_$index"
//							val normalizedListPrefix = normalizeKey(listPrefix)
//
//							when (element) {
//								is String -> {
//									val messageKey = messageKeyMap[normalizedListPrefix]
//									if (messageKey != null) {
//										logger.logIfDebug("Mapping list item: $normalizedListPrefix -> $element")
//										messageMap[messageKey] = element
//									} else {
//										logger.logIfDebug("No message key found for list item path: $normalizedListPrefix", LogLevel.WARN)
//									}
//								}
//								is Map<*, *> -> {
//									logger.logIfDebug("Encountered nested map in list at path: $normalizedListPrefix; diving deeper")
//									processYamlData(listPrefix, element as Map<String, Any>, messageKeyMap, messageMap)
//								}
//								else -> {
//									logger.logIfDebug("Unexpected value type in list at path $normalizedListPrefix: ${element?.let { it::class.simpleName } ?: "null"}")
//								}
//							}
//						}
//					}
//
//					is Map<*, *> -> {
//						logger.logIfDebug("Encountered nested structure at path: $normalizedPrefix; diving deeper")
//						processYamlData(currentPrefix, value as Map<String, Any>, messageKeyMap, messageMap)
//					}
//
//					else -> {
//						logger.logIfDebug("Unexpected value type at path $normalizedPrefix: ${value::class.simpleName}")
//					}
//				}
//			}
//
//			logger.logIfDebug("Completed YAML data processing for prefix: '$prefix'")
//		}
//
//		private fun collectYamlKeysFromMessages(
//			messages: Map<MessageKey<P, C>, String>,
//			yamlKeys: MutableSet<String>
//		) {
//			for (messageKey in messages.keys) {
//				val normalizedKey = normalizeKey(messageKey.rc())
//				yamlKeys.add(normalizedKey)
//			}
//		}
//	}